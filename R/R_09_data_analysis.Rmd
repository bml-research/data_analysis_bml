---
title: "R Data Analysis"
author: ""
date: ""
output: 
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---

![](../hanze/hanze.png)

---

[Go back to the main page](../index.html)  
[Go back to the R overview page](../R/R_01_index.html)  

---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

This Rmd file can be downloaded [here](./R_09_data_analysis.Rmd).  

Files used on this page:  
- [file01_dementia_patients_health_data.csv](./files_09_data_analysis/file01_dementia_patients_health_data.csv)  



# R: Data Analysis

## Data analysis methods

Let's start with loading the `Tidyverse` library:

```{r}
library(tidyverse)
```

>The following function is used to print tibbles in a proper way for the web. You can skip the use of this function to print tibbles to your screen in R Markdown documents.


```{r}
library(knitr)
library(kableExtra)
library(pillar)

formatted_table <- function(df) {
  col_types <- sapply(df, pillar::type_sum)
  new_col_names <- paste0(names(df), "<br>", "<span style='font-weight: normal;'>", col_types, "</span>")
  kbl(df, 
      col.names = new_col_names, 
      escape = FALSE, # This is crucial to allow the <br> tag to work
      format = "html" # Ensure HTML format, although often auto-detected
      ) %>%
    kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
}
```

Here we will focus on data transformation and analysis.
We will filter rows with `filter()`, arrange rows with `arrange()` and select columns with `select()`.
In addition, we will make grouped summaries using `summarize()`.
At last, we will do some basic calculations. Note that plotting data will be the subject of the next section.

>Note: R is like a swiss army knife. Extremely powerfull but also very eloborate.
>It is impossible to cover all analysis functions of R.
>So this is not a complete guide for data analysis. Instead, this course will focus on some common tasks.
>You can always elaborate your analysis by exploring the Tidyverse documentation. Or even use the base R documentation if the specific task you want to perform some custom tasks.  
>See: [tidyverse documentation](https://style.tidyverse.org/documentation.html)  
>See: [base R documentation](https://cran.r-project.org/manuals.html)

  
## Loading a dataset

As an example data set, we will be using the same data set as used in the Excel section:
namely, the `Dementia Patient Health,Prescriptions ML Dataset`.

```{r}
file_path <- "./files_09_data_analysis/file01_dementia_patients_health_data.csv"
df <- read_csv(file_path)
formatted_table(head(df))
```

As you can see above, the data is loaded well. Also note that the columns are of the correct data type (e.g. *numeric* for the `HeartRate` and `Weight` columns and *character* for `Prescription` and `Gender`).

  
## Select rows by index

You can select rows by index using the following notation:

```{r}
formatted_table(df[2, ]) #select second row
```

Note the comma between the brackets. Since there is no specification of a column, all columns are selected.

## Select column by index


You can also select a column based on an index:

```{r}
formatted_table(head(df[, 8])) #select eighth column
```

The `head()` function was used to truncate the output.

## Select column by name

You can also select a column by name:

```{r}
head(df$Prescription) #select column Prescription
```

Note that this action returns a vector instead of a data frame.

  
## Select item by index

You can also select a specific item by index:

```{r}
formatted_table(df[2, 8]) #select second row and eighth column
```

Now we have the value of the second row and the eighth column.

## Analysis with Tidyverse functions

The previous examples where all examples of base R. We will now focus on some commonly used Tidyverse functions for the analysis and plotting (next lessons).

Herewith a table with some commonly used Tidyverse functions and the applications:  

| Package | Function | Primary Purpose | Description |
| :--- | :--- | :--- | :--- |
| **`dplyr`** | `filter()` | Subset rows | Selects a subset of rows based on column values that meet specified logical conditions. |
| **`dplyr`** | `slice()` | Subset rows by position | Selects rows by their integer position in the data frame. Also includes helpers like `slice_head()`, `slice_tail()`, `slice_min()`, `slice_max()`, and `slice_sample()`. |
| **`dplyr`** | `select()` | Subset columns | Selects, drops, or reorders columns by their names. |
| **`dplyr`** | `mutate()` | Add/Modify columns | Adds new columns or modifies existing ones based on a formula. |
| **`dplyr`** | `arrange()` | Reorder rows | Sorts rows by the values of specified column(s) in ascending or descending order. |
| **`dplyr`** | `group_by()` | Group data | Creates grouped data that subsequent functions (like `summarize()`) operate on for each group. |
| **`dplyr`** | `summarize()` | Summarize data | Reduces multiple values down to a single summary statistic (e.g., mean, count, standard deviation). |
| **`dplyr`** | `inner_join()` | Combine data | Joins two data frames by matching keys, keeping only rows that have matches in *both* tables. |
| **`tidyr`** | `pivot_longer()` | Reshape data | Lengthens data, increasing the number of rows and decreasing the number of columns. |
| **`tidyr`** | `pivot_wider()` | Reshape data | Widens data, decreasing the number of rows and increasing the number of columns. |
| **`ggplot2`**| `ggplot()` | Create visualizations | Initializes a ggplot object, defining the data and aesthetic mappings. |
| **Base R** | `%>%` (pipe) | Chaining operations | Feeds the result of one function directly into the first argument of the next function. |


Some examples will follow below.  


## Slicing with slice

Tidyverse uses the `slice` function (and variants) to slice your tibbles.  
Some examples:  

Slice the first row:

```{r}
df %>%
  slice(1) %>%
  formatted_table()
```

Or the second to fifth row:  

```{r}
df %>%
  slice(2:5) %>%
  formatted_table()
```


You can use `slice_head` to get the upper `n` rows:   

```{r}
df %>%
  slice_head(n=5) %>%
  formatted_table()
```

Or `slice_tail` to get the last `n` rows:  

```{r}
df %>%
  slice_tail(n=5) %>%
  formatted_table()
```


Using `slice_max` you can get the row with a max value (for example the max Alcohol level):  

```{r}
df %>%
  slice_max(order_by = AlcoholLevel, n=1) %>%
  formatted_table()
```


Note that this is the same as the following in base R (but easier to read):  

```{r}
formatted_table(df[df$AlcoholLevel == max(df$AlcoholLevel), ])
```


There is also a `slice_min` function.  

## Filter rows

One of the most frequent tasks that you will be doing on data frames is filtering rows.
Here is how that works in R:  

>Note that `slice_head()` is used to reduce the output to 6 rows.  
>Try it yourself without the ``slice_head()` to compare the output.  

Filter rows on all patients of age 65:

```{r}
df %>%
  filter(Age == 65) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

Measured oxygen level in blood considered as normal (>95):

```{r}
df %>%
  filter(BloodOxygenLevel > 95) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

To add a second condition, the `&` operator is used:  
Current smoker (condition 1) AND normal blood oxygen levels (condition 2):

```{r}
df %>%
  filter(Smoking_Status == "Current Smoker" & BloodOxygenLevel > 95) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

The `!` operator can be used to exclude (negate) a specific condition:  
NOT a current smoker AND normal blood oxygen levels:

```{r}
df %>% 
  filter(!Smoking_Status == "Current Smoker" & BloodOxygenLevel > 95) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

The `|` operator can be used to meet either one of the conditions:
Normal blood oxygen levels OR very low blood oxygen levels:

```{r}
df %>%
  filter(BloodOxygenLevel < 92 | BloodOxygenLevel > 95) %>%
  slice_head(n = 6) %>%
  formatted_table()
```


## Arranging rows

You can use `arrange()` instead of `filter()` if you want to sort your rows in a data frame instead of filtering it:

Arrange on blood oxygen levels **ascending** (from low to high values):

```{r}
df %>%
  arrange(BloodOxygenLevel) %>%
  slice_head(n = 6) %>%
  formatted_table()
```


If you want to sort in **descending** order (from high to low values):

```{r}
df %>%
  arrange(desc(BloodOxygenLevel)) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

And to select the row with the highest value:

```{r}
df %>%
  arrange(desc(BloodOxygenLevel)) %>%
  slice_head(n = 1) %>%
  formatted_table()
```

You can also do some multi-level sorting:

Here is an example of sorting on age first and then sorting on blood oxygen levels: 

```{r}
df %>%
  arrange(Age, BloodOxygenLevel) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

Here is an example of sorting on age first and then sorting on **descending** blood oxygen levels (from high to low): 

```{r}
df %>%
  arrange(Age, desc(BloodOxygenLevel)) %>%
  slice_head(n = 6) %>%
  formatted_table()
```


>Note: Missing values will always be sorted at the end.

  
## Select columns with select

You have learned that variables in data sets should be arranged in columns. Often data sets contain a lot of variables (columns). Most likely, you are not interested in all of them.
With the `select()` function, you can select the variables that you are interested in:

```{r}
df %>%
  select(Age, Smoking_Status, BloodOxygenLevel, HeartRate) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

Or select all columns except the blood oxygen levels:

```{r}
df %>%
  select(-BloodOxygenLevel) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

Or select besides the age, all column names that end with "Level":

```{r}
df %>%
  select(Age, ends_with("Level")) %>%
  slice_head(n = 6) %>%
  formatted_table()
```

Yes, there is also a function `starts_With()` to select columns that start with certain characters.  


## Summary data

You can use the base R `summary()` function to get summary information on a data frame:

```{r}
summary(df)
```

As this output can be quit overwhelming you may select for the data that you are interested in (for example blood oxygen levels):

```{r}
summary(df$BloodOxygenLevel)
```

But the Tidyverse library also contains a `summarize()` function:

```{r}
df %>% 
  summarize(BloodOxygenLevel = mean(BloodOxygenLevel)) %>%
  formatted_table()
```

You can combine this with the `group_by()` function for powerful analysis:

```{r}
df %>%
  group_by(Smoking_Status) %>%
  summarize(Average_BloodOxygenLevel = mean(BloodOxygenLevel)) %>%
  formatted_table()
```

Recall that this looks very much like the pivot table function in Excel (see figure 28 at [data analysis Excel](https://bml-research.github.io/data_analysis/excel/excel_08_data_analysis.html)).

To create a similar output as the pivot tables in Excel:

```{r}
df %>%
  group_by(Smoking_Status) %>%
  summarize(average_BOL = mean(BloodOxygenLevel), average_BT = mean(BodyTemperature)) %>%
  formatted_table()
```


Now compare this output with figure 28 at [data analysis Excel](https://bml-research.github.io/data_analysis/excel/excel_08_data_analysis.html).

Likewise, you can extend this by providing the standard deviation:

```{r}
df %>% 
  group_by(Smoking_Status) %>%
  summarize(average_BOL = mean(BloodOxygenLevel), sd_BOL = sd(BloodOxygenLevel), average_BT = mean(BodyTemperature), sd_BT = sd(BodyTemperature)) %>%
  formatted_table()
```
  
  
## Round values

In R you can round decimals using the `round()` function:

```{r}
round(2.40, digits = 1)
round(2.45, digits = 1)
round(2.45) #defaults to 0 digits
round(2.5) #defaults to 0 digits
```

>Note that for rounding off a 5, the IEC 60559 standard (see also ‘IEEE 754’) is expected to be used, ‘go to the even digit’. Therefore round(0.5) is 0 and round(-1.5) is -2.

So if you like your values to be rounded in the example above, just wrap it in the `round()` function:

```{r}
df %>% 
  group_by(Smoking_Status) %>%
  summarize(average_BOL = round(mean(BloodOxygenLevel), digits = 1), 
            sd_BOL = round(sd(BloodOxygenLevel), digits = 2), 
            average_BT = round(mean(BodyTemperature), digits = 1), 
            sd_BT = round(sd(BodyTemperature), digits = 2)) %>%
  formatted_table()
```
  
  
## Statistics

R is build for statistics so you can do all kind of sophisticated statistics in R.
As this is not a statistics course, the use of statistics is beyond the scope of this course.

Some very basic functions that might be useful (all applied on the BloodOxygenLevel column):

```{r}
paste("mean:", round(mean(df$BloodOxygenLevel), digits = 3))
paste("min:", round(min(df$BloodOxygenLevel), digits = 2))
paste("max:", round(max(df$BloodOxygenLevel), digits = 2))
paste("median:", round(median(df$BloodOxygenLevel), digits = 2))
round(quantile(df$BloodOxygenLevel, c(0.25, 0.5, 0.75)), digits = 2)
paste("standard deviation:", round(sd(df$BloodOxygenLevel), digits = 3))
paste("standard error of the mean:", round(sd(df$BloodOxygenLevel)/sqrt(length(df$BloodOxygenLevel)), digits = 3)) #can also be calculated using the plotrix package
```

## Summarize each

Using Tidyverse, you can also apply some of the above statistics more conveniently using the `summarize_each()` function:

```{r}
df %>% 
  group_by(Smoking_Status) %>%
  summarize_each(funs(mean, sd, se=sd(.)/sqrt(n()))) %>%
  formatted_table()
```

Note: that the `se=sd(.)/sqrt(n())` code is a custom made function to calculate the standard error of the mean.

Columns with characters cannot be used to do these kind of calculations. If you check the complete formatted table you will find that these are empty (`NA`). For example the column for Prescription; it is not possible to calculate the mean value for character type of data (in this case: name of the medicine). So it is best to omit them:

```{r}
df %>%
  group_by(Smoking_Status) %>%
  summarize_each(funs(mean, sd, se=sd(.)/sqrt(n()))) %>%
  select(-Prescription_mean) %>%
  formatted_table()
```


In this case, we can also remove all character type columns at once (and then do the calculations) as follows.
The code is a bit complex and therefore we added explanations to each line:  

```{r}
df %>%
  # 1. Group the data FIRST by the categorical variable
  group_by(Smoking_Status) %>%
  # 2. Summarize the data, applying functions ACROSS all numeric columns
  summarise(
    # Use across() to select columns and apply multiple functions
    # .cols = where(is.numeric) selects all numeric columns
    # .fns = list(...) applies the functions
    across(
      .cols = where(is.numeric),
      .fns = list(
        mean = mean,
        sd = sd,
        se = ~ sd(.) / sqrt(n()) # The tilde (~) creates an anonymous function for SE
      )
    )
  ) %>%
  # 3. Apply the custom/formatting function
  formatted_table()
```
This way, the only character type column that is preserved is the `Smoking_Status` column.
Note: there are still fields with `NA` in this overview. These are caused by missing values in the original dataset. If you try to calculate the mean value of a set of numbers, including `NA`, the result will be `NA`:

```{r}
paste("mean with no `NA` values:", mean(c(5.7, 3.5, 2.7, 4.6, 7.9)))
paste("mean with `NA` values:", mean(c(5.7, 3.5, 2.7, NA, 7.9)))
paste("standard deviation with no `NA` values:", sd(c(5.7, 3.5, 2.7, 4.6, 7.9)))
paste("standard deviation with `NA` values:", sd(c(5.7, 3.5, 2.7, NA, 7.9)))
paste("sum with no `NA` values:", sum(c(5.7, 3.5, 2.7, 4.6, 7.9)))
paste("sum with `NA` values:", sum(c(5.7, 3.5, 2.7, NA, 7.9)))
```
We can get around this problem using the `na.rm =` argument in the functions used. The default setting is `na.rm = FALSE`. If we set this argument to `TRUE`, all `NA` values will be removed before the mean/sd/sum is calculated.

```{r}
paste("mean with no `NA` values:", mean(c(5.7, 3.5, 2.7, 4.6, 7.9)))
paste("mean with `NA` values:", mean(c(5.7, 3.5, 2.7, NA, 7.9), na.rm = TRUE))
paste("standard deviation with no `NA` values:", sd(c(5.7, 3.5, 2.7, 4.6, 7.9)))
paste("standard deviation with `NA` values:", sd(c(5.7, 3.5, 2.7, NA, 7.9), na.rm = TRUE))
paste("sum with no `NA` values:", sum(c(5.7, 3.5, 2.7, 4.6, 7.9)))
paste("sum with `NA` values:", sum(c(5.7, 3.5, 2.7, NA, 7.9), na.rm = TRUE))
```

### Summarize and across

The `summarize_each()` function is deprecated (will work, but not actively maintained anymore) in favor of the new `across()` function that works within `summarize()` and `mutate()`.  

```{r}
df %>%
  group_by(Smoking_Status) %>%
  summarize(across(everything(), list(mean = mean, sd = sd))) %>%
  formatted_table()
```

Or use the scoped variant of summarize, `summarize_all()`:  

```{r}
df %>%
  group_by(Smoking_Status) %>%
  summarize_all(list(mean = mean, sd = sd)) %>%
  formatted_table()
```

If you want to remove the columns that yield `NA’s`:  

```{r}
df %>% 
  select_if(~sum(!is.na(.)) > 0) %>%
  slice_head(n = 6) %>%
  formatted_table()
```



---

[Go back to the main page](../index.html)  
[Go back to the R overview page](../R/R_01_index.html)  
<a href="#top">⬆️ Back to Top</a>  

---


>This web page is distributed under the terms of the Creative Commons Attribution License which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited.
>Creative Commons License: CC BY-SA 4.0.

